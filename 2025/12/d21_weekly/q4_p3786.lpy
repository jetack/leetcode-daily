;;; Failed during the contest
(require lispy.macros *)

(do
  (defmacro leetcode [fnname *examples]
    (return `(do (class Solution []
                   (def ~fnname [self *args **kwargs]
                     (return (solution *args **kwargs))))
                 ~(ife examples
                       `(do
                          (from pprint [pprint])
                          (for [args expected] ~examples
                            (= ans (solution *args))
                            (when (!= ans expected)
                              (print "\nargs:")
                              (pprint args)
                              (print "expected:")
                              (pprint expected)
                              (print "answer:")
                              (pprint ans))))
                       None))))

  ;; frequently used
  (from collections *)
  (from heapq *))

(def solution [n edges group]
  (= connections [[] for _ in (range n)])
  (for [s e] in edges
    (.append (sub connections s) e)
    (.append (sub connections e) s))
  
  (= groups [(set) for _ in (range 21)])
  (for i (range n)
    (.add (sub groups (sub group i)) i))

  (def group-solver [group]
    (= l (len group))
    (def recur [cur prev]
      (= n-mem (ife (in cur group)
                    1 0))
      (= costs 0)
      (for ncur (sub connections cur)
        (when (== ncur prev)
          (continue))
        (= [next-mem next-costs] (recur ncur cur))
        (+= n-mem next-mem)
        (+= costs next-costs)
        (+= costs (* next-mem (- l next-mem))))
      (return [n-mem costs]))
    (return (sub (recur (group.pop) -1) -1)))

  (= rst 0)
  (for group (filter (fn [x] (> (len x) 1))
                     groups)
    (+= rst (group-solver group)))
  (return rst))

(leetcode interactionCosts
          [[4 [[0 3] [1 2] [0 1]] [1 4 4 4]]
           6])

