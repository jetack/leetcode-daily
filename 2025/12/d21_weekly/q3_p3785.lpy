(require lispy.macros *)

(defmacro leetcode [fnname *examples]
  (return `(do (class Solution []
                 (def ~fnname [self *args **kwargs]
                   (return (solution *args **kwargs))))
               ~(ife examples
                     `(do
                        (from pprint [pprint])
                        (for [args expected] ~examples
                          (= ans (solution *args))
                          (when (!= ans expected)
                            (print "\nargs:")
                            (pprint args)
                            (print "expected:")
                            (pprint expected)
                            (print "answer:")
                            (pprint ans))))
                     None))))

(from collections [Counter])
(from heapq *)

(def solution [nums forbidden]
  (def max-heapify [lst]
    (= rst [-x for x in lst])
    (heapify rst)
    (return rst))

  (def max-heappop [max-heap]
    (return (- (heappop max-heap))))

  (def max-heappush [max-heap item]
    (heappush max-heap -item)
    (return max-heap))

  (= numcnt (Counter))
  (= fcnt (Counter))
  (= matchcnt (Counter))
  (= n (len nums))
  (for [num f] (zip nums forbidden)
    (+= (sub numcnt num) 1)
    (+= (sub fcnt f) 1)
    (when (== num f)
      (+= (sub matchcnt num) 1)))
  (when (not matchcnt)
    (return 0))
  (for num numcnt
    (when (> (sub numcnt num)
             (- n (sub fcnt num)))
      (return -1)))
  (= hq (max-heapify (list (.values matchcnt))))
  (= rst 0)
  (while (> (len hq) 1)
    (= e1 (max-heappop hq))
    (= e2 (max-heappop hq))
    (+= rst e2)
    (max-heappush hq (- e1 e2)))
  (return (+ (max-heappop hq) rst)))

(leetcode minSwaps)
