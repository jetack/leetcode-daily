(require lispy.macros *)

(defmacro leetcode [fnname *examples]
  (return `(do (class Solution []
                 (def ~fnname [self *args **kwargs]
                   (return (solution *args **kwargs))))
               ~(ife examples
                     `(do
                        (from pprint [pprint])
                        (for [args expected] ~examples
                          (= ans (solution *args))
                          (when (!= ans expected)
                            (print "\nargs:")
                            (pprint args)
                            (print "expected:")
                            (pprint expected)
                            (print "answer:")
                            (pprint ans))))
                     None))))

(from collections [Counter])

(def solution [nums forbidden]
  (= numcnt (Counter))
  (= fcnt (Counter))
  (= matchcnt (Counter))
  (= maxmatch 0)
  (= totalmatch 0)
  (= n (len nums))
  (for [num f] (zip nums forbidden)
    (++ (sub numcnt num))
    (++ (sub fcnt f))
    (when (== num f)
      (++ totalmatch)
      (++ (sub matchcnt num))
      (= maxmatch (max maxmatch (sub matchcnt num)))))
  (when (not matchcnt)
    (return 0))
  (for num numcnt
    (when (> (sub numcnt num)
             (- n (sub fcnt num)))
      (return -1)))
  (return (max maxmatch (-> totalmatch
                            (+ 1)
                            (// 2)))))

(leetcode minSwaps)
