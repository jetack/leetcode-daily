(require lispy.macros *)
(require leetcode *)

(from leetcode *)

(def solution [n meetings]
  (.sort meetings)
  (= occupied [])
  (= vacancies (list (range n)))
  (heapify vacancies)
  (= nmeets (* [0] n))
  (for m meetings
    (= [s e] m)
    (while (and occupied (<= (sub occupied 0 0) s))
      (heappush vacancies (-> occupied (heappop) (sub 1))))
    (if vacancies
        (do
          (= r (heappop vacancies))
          (heappush occupied [e r]))
        (do
          (= [f r] (heappop occupied))
          (heappush occupied [(+ e (- f s)) r])))
    (++ (sub nmeets r)))
  (return (-> nmeets
              (enumerate)
              (max :key (fn [x] (sub x 1)))
              (sub 0))))

(leetcode mostBooked
          [(, 2 [[0,10],[1,5],[2,7],[3,4]])
           0])
