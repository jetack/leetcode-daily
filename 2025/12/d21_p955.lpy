(require lispy.macros *)

(defmacro leetcode [fnname *examples]
  (return `(do (class Solution []
                 (def ~fnname [self *args **kwargs]
                   (return (solution *args **kwargs))))
               ~(ife examples
                     `(do
                        (from pprint [pprint])
                        (for [args expected] ~examples
                          (= ans (solution *args))
                          (when (!= ans expected)
                            (print "\nargs:")
                            (pprint args)
                            (print "expected:")
                            (pprint expected)
                            (print "answer:")
                            (pprint ans))))
                     None))))

(from collections [defaultdict])

(def solution [strs]
  (= l (len (sub strs 0)))
  (def recur [ties :i 0]
    (when (or (not ties)
              (>= i l))
      (return 0))
    (= deleted False)
    (= tied False)
    (= new-ties [])
    (for strs in ties
      (new-ties.append [(sub strs 0)])
      (for j (range 1 (len strs))
        (cond (> (sub strs (dec j) i)
                 (sub strs j i))
              (do
                (= deleted True)
                (break))

              (== (sub strs (dec j) i)
                  (sub strs j i))
              (do
                (= tied True)
                (.append (sub new-ties -1) (sub strs j)))

              (new-ties.append [(sub strs j)])))
      (when deleted
        (break)))

    (return (conde deleted
                   (inc (recur ties (inc i)))

                   tied
                   (recur (list (filter (fn [x] (> (len x) 1))
                                        new-ties))
                          (inc i))

                   0)))
  (return (recur [strs])))

(leetcode minDeletionSize
          [(, ["ca" "bb" "ac"]) 1]
          [(, ["xc" "yb" "za"]) 0]
          [(, ["zyx" "wvu" "tsr"]) 3]
          )
